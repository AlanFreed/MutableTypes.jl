<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · MutableTypes.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>MutableTypes.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Methods"><span>Methods</span></a></li><li><a class="tocitem" href="#Unary-Operators"><span>Unary Operators</span></a></li><li><a class="tocitem" href="#Binary-Operators"><span>Binary Operators</span></a></li><li><a class="tocitem" href="#Functions:-all-numeric-types."><span>Functions: all numeric types.</span></a></li><li><a class="tocitem" href="#Functions:-all-non-complex-numeric-types."><span>Functions: all non-complex numeric types.</span></a></li><li><a class="tocitem" href="#Functions:-rational-numbers."><span>Functions: rational numbers.</span></a></li><li><a class="tocitem" href="#Functions:-real-numbers."><span>Functions: real numbers.</span></a></li><li><a class="tocitem" href="#Functions:-complex-numbers."><span>Functions: complex numbers.</span></a></li><li><a class="tocitem" href="#Functions:-math"><span>Functions: math</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MutableTypes.jl"><a class="docs-heading-anchor" href="#MutableTypes.jl">MutableTypes.jl</a><a id="MutableTypes.jl-1"></a><a class="docs-heading-anchor-permalink" href="#MutableTypes.jl" title="Permalink"></a></h1><p>This package provides mutable boolean, integer, rational, real and complex types. Their arithmetic operators are overloaded. The package also exports wrappers for the more common math functions.</p><p>The intended use of these mutable types is to serve as fields within immutable data structures that contain a field or fields that need the capability to have their values changed during runtime. For example, a data structure that holds material properties may include a boolean field &#39;ruptured&#39; that would get turned on (converted from false to true) after a rupture event has occurred, thereafter enabling a change in material properties to take place moving forward.</p><p>All operators and functions supply instances of the core types, viz., <code>Bool</code>, <code>Integer</code>, <code>Rational</code>, <code>Real</code> and <code>Complex</code>, as appropriate. They do not supply instances of their mutable versions. This is in accordance with the intended use of these mutable types, i.e., they are to serve as mutable fields within an otherwise immutable data structure.</p><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><p>MutableTypes.jl exports two abstract types, and five implementations of them.</p><h3 id="Abstract-Types"><a class="docs-heading-anchor" href="#Abstract-Types">Abstract Types</a><a id="Abstract-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Types" title="Permalink"></a></h3><p><code>MType</code> is the core type for mutable types. It is a subtype of base type <code>Number</code>, and is defined by</p><pre><code class="nohighlight hljs">abstract type MType &lt;: Number end</code></pre><p>Additionally, <code>MNumber</code> is a subtype of core type <code>MType</code>, and is defined by</p><pre><code class="nohighlight hljs">abstract type MNumber &lt;: MType end</code></pre><h3 id="Concrete-Types"><a class="docs-heading-anchor" href="#Concrete-Types">Concrete Types</a><a id="Concrete-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Concrete-Types" title="Permalink"></a></h3><p>Mutable booleans are instances of <code>MType</code>, whose single field <code>n</code> is of type <code>Bool</code>; specifically,</p><pre><code class="nohighlight hljs">mutable struct MBool &lt;: MType
    n::Bool
end</code></pre><p>Recall that <code>Bool &lt;: Integer &lt;: Real &lt;: Number</code>.</p><p>Mutable integers are instances of <code>MNumber</code>, whose single field <code>n</code> is of type <code>Int64</code>; specifically,</p><pre><code class="nohighlight hljs">mutable struct MInteger &lt;: MNumber
    n::Int64
end</code></pre><p>Recall that <code>Int64 &lt;: Signed &lt;: Integer &lt;: Real &lt;: Number</code>.</p><p>Mutable rationals are instances of <code>MNumber</code>, whose single field <code>n</code> is of type <code>Rational{Int64}</code>; specifically,</p><pre><code class="nohighlight hljs">mutable struct MRational &lt;: MNumber
    n::Rational{Int64}
end</code></pre><p>Recall that <code>Rational &lt;: Real &lt;: Number</code>.</p><p>Mutable reals are instances of <code>MNumber</code>, whose single field <code>n</code> is of type <code>Float64</code>; specifically,</p><pre><code class="nohighlight hljs">mutable struct MReal &lt;: MNumber
    n::Float64
end</code></pre><p>Recall that <code>Float64 &lt;: AbstractFloat &lt;: Real &lt;: Number</code>.</p><p>Mutable complex are instances of <code>MType</code>, whose single field <code>n</code> is of type <code>Complex{Float64}</code>; specifically,</p><pre><code class="nohighlight hljs">mutable struct MComplex &lt;: MType
    n::Complex{Float64}
end</code></pre><p>Recall that <code>Complex &lt;: Number</code>.</p><p>Constructors for these mutable types have the appearance of being type castings. For example, </p><pre><code class="nohighlight hljs">truth = MBool(true)
five = MInteger(5)
threeHalves = MRational(3//2)
pi = MReal(3.14159)
i = MComplex(0+1im)</code></pre><h2 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h2><h3 id="get()"><a class="docs-heading-anchor" href="#get()">get()</a><a id="get()-1"></a><a class="docs-heading-anchor-permalink" href="#get()" title="Permalink"></a></h3><p>Method <code>get</code> extends method <code>Base.get</code>. Calls to <code>MutableTypes.get</code> return the value held by field <code>n</code> for instances of the above mutable types; specifically,</p><pre><code class="nohighlight hljs">function Base.:(get)(y::MBool)::Bool
function Base.:(get)(y::MInteger)::Integer
function Base.:(get)(y::MRational)::Rational
function Base.:(get)(y::MReal)::Real
function Base.:(get)(y::MComplex)::Complex</code></pre><h3 id="set!()"><a class="docs-heading-anchor" href="#set!()">set!()</a><a id="set!()-1"></a><a class="docs-heading-anchor-permalink" href="#set!()" title="Permalink"></a></h3><p>Method <code>set!</code> assigns the supplied value <code>x</code> to field <code>n</code> held by the mutable type. (<em>Note:</em> there is no method <code>Base.set!</code> to inherit that pairs with method <code>Base.get</code>.) Their interfaces are</p><pre><code class="nohighlight hljs">function set!(y::MBool, x::Bool)
function set!(y::MInteger, x::Integer)
function set!(y::MRational, x::Rational)
function set!(y::MReal, x::Real)
function set!(y::MComplex, x::Complex)</code></pre><h3 id="toString()"><a class="docs-heading-anchor" href="#toString()">toString()</a><a id="toString()-1"></a><a class="docs-heading-anchor-permalink" href="#toString()" title="Permalink"></a></h3><p>Method <code>toString</code> converts numbers into their string representation. For uniformity of structure, these methods are also provided for the core types via</p><pre><code class="nohighlight hljs">function toString(y::Bool; aligned::Bool=false)::String
function toString(y::Integer; aligned::Bool=false)::String
function toString(y::Rational; aligned::Bool=false)::String
function toString(y::Real; format::Char=&#39;E&#39;, precision::Int=5, aligned::Bool=false)::String
function toString(y::Complex; format::Char=&#39;E&#39;, precision::Int=5,  aligned::Bool=false)::String</code></pre><p>with the mutable types having like interfaces of</p><pre><code class="nohighlight hljs">function toString(y::MBool; aligned::Bool=false)::String
function toString(y::MInteger; aligned::Bool=false)::String
function toString(y::MRational; aligned::Bool=false)::String
function toString(y::MReal; format::Char=&#39;E&#39;, precision::Int=5, aligned::Bool=false)::String
function toString(y::MComplex; format::Char=&#39;E&#39;, precision::Int=5, aligned::Bool=false)::String</code></pre><p>These methods have keywords with default values, which include:</p><ul><li><p>Keyword <code>aligned</code>, if set to <code>true</code> (the default is <code>false</code>), will right-align strings. This is useful when, e.g., printing arrays or matrices of values. For instances of <code>Bool</code> and <code>MBool</code>, a whitespace will preceed &quot;true&quot; strings so that they will read &quot;  true&quot;, and will therefore right align with instances of &quot;false&quot;. For all numeric types, a whitespace will preceed all non-negative values so that they read &quot;  &lt;value&gt;&quot;, and will therefore right align with negative numbers.</p></li><li><p>Keyword <code>format</code> applies to floating-point numbers, i.e., instances of <code>Real</code>, <code>Complex</code>, <code>MReal</code> and <code>MComplex</code>. It differentiates exponential (i.e., scientific) notation from fixed-point notation in their string representations. The default is an exponential notation with a capital &#39;E&#39; in the string. A lower-case &#39;e&#39; will be used whenever <code>format=&#39;e&#39;</code>. All other <code>Char</code> values will result in a fixed-point representation of the number.</p></li><li><p>Keyword <code>precision</code> specifies the number of significant figures that are to be retained in the string representation of a floating-point number. The default is 5, but any integer value within the interval [3,…,7] is admissible.</p></li></ul><h3 id="copy()"><a class="docs-heading-anchor" href="#copy()">copy()</a><a id="copy()-1"></a><a class="docs-heading-anchor-permalink" href="#copy()" title="Permalink"></a></h3><p>Method <code>copy</code> extends method <code>Base.copy</code>. Calls to <code>MutableTypes.copy</code> return a shallow copy of the supplied argument; specifically,</p><pre><code class="nohighlight hljs">function Base.:(copy)(y::MBool)::MBool
function Base.:(copy)(y::MInteger)::MInteger
function Base.:(copy)(y::MRational)::MRational
function Base.:(copy)(y::MReal)::MReal
function Base.:(copy)(y::MComplex)::MComplex</code></pre><h3 id="deepcopy()"><a class="docs-heading-anchor" href="#deepcopy()">deepcopy()</a><a id="deepcopy()-1"></a><a class="docs-heading-anchor-permalink" href="#deepcopy()" title="Permalink"></a></h3><p>Method <code>deepcopy</code> extends method <code>Base.deepcopy</code>. Calls to <code>MutableTypes.deepcopy</code> return a deep copy of the supplied argument; specifically,</p><pre><code class="nohighlight hljs">function Base.:(deepcopy)(y::MBool)::MBool
function Base.:(deepcopy)(y::MInteger)::MInteger
function Base.:(deepcopy)(y::MRational)::MRational
function Base.:(deepcopy)(y::MReal)::MReal
function Base.:(deepcopy)(y::MComplex)::MComplex</code></pre><h2 id="Unary-Operators"><a class="docs-heading-anchor" href="#Unary-Operators">Unary Operators</a><a id="Unary-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Unary-Operators" title="Permalink"></a></h2><p>These operators extend their equivalent unary operators exported by module <code>Base</code>.</p><h3 id="!"><a class="docs-heading-anchor" href="#!">!</a><a id="!-1"></a><a class="docs-heading-anchor-permalink" href="#!" title="Permalink"></a></h3><p>Unary operator <code>!</code> negates the MBool value to the right of the operator. This operator is overloaded to handle</p><pre><code class="nohighlight hljs">function Base.:!(y::MBool)::Bool</code></pre><h3 id><a class="docs-heading-anchor" href="#">+</a><a id="-1"></a><a class="docs-heading-anchor-permalink" href="#" title="Permalink"></a></h3><p>Unariy operator <code>+</code> retains the value to the mutable type to the right of the operator. This operator is overloaded to handle</p><pre><code class="nohighlight hljs">function Base.:+(y::MInteger)::Integer
function Base.:+(y::MRational)::Rational
function Base.:+(y::MReal)::Real
function Base.:+(y::MComplex)::Complex</code></pre><h3 id="-2"><a class="docs-heading-anchor" href="#-2">-</a><a class="docs-heading-anchor-permalink" href="#-2" title="Permalink"></a></h3><p>Unary operator <code>-</code> negates the value of the mutable type to the right of the operator. This operator is overloaded to handle</p><pre><code class="nohighlight hljs">function Base.:-(y::MInteger)::Integer
function Base.:-(y::MRational)::Rational
function Base.:-(y::MReal)::Real
function Base.:-(y::MComplex)::Complex</code></pre><h2 id="Binary-Operators"><a class="docs-heading-anchor" href="#Binary-Operators">Binary Operators</a><a id="Binary-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Binary-Operators" title="Permalink"></a></h2><p>These operators extend their equivalent binary operators exported by module <code>Base</code>.</p><h3 id="-3"><a class="docs-heading-anchor" href="#-3">==</a><a class="docs-heading-anchor-permalink" href="#-3" title="Permalink"></a></h3><p>Binary operator <code>==</code> tests to determine if the argument to the left equals the argument to the right. This operator is overloaded to handle comparisons of</p><pre><code class="nohighlight hljs">function Base.:(==)(y::MType, z::MType)::Bool
function Base.:(==)(y::Union{Bool,Real,Complex}, z::MType)::Bool
function Base.:(==)(y::MType, z::Union{Bool,Real,Complex})::Bool</code></pre><h3 id="-4"><a class="docs-heading-anchor" href="#-4">≠</a><a class="docs-heading-anchor-permalink" href="#-4" title="Permalink"></a></h3><p>Binary operator <code>≠</code> tests to determine if the argument to the left does not equal the argument to the right. This operator is overloaded to handle comparisons of</p><pre><code class="nohighlight hljs">function Base.:≠(y::MType, z::MType)::Bool
function Base.:≠(y::Union{Bool,Real,Complex}, z::MType)::Bool
function Base.:≠(y::MType, z::Union{Bool,Real,Complex})::Bool</code></pre><h3 id="-5"><a class="docs-heading-anchor" href="#-5">≈</a><a class="docs-heading-anchor-permalink" href="#-5" title="Permalink"></a></h3><p>Binary operator <code>≈</code> tests to determine if the argument to the left is approximately equal to the argument to the right. This operator applies to floating-points objects and tests for equality of at least 32-bit precision between two 64-bit numbers. This operator is overloaded to handle comparisons of</p><pre><code class="nohighlight hljs">function Base.:≈(y::MReal, z::MReal)::Bool
function Base.:≈(y::Real, z::MReal)::Bool
function Base.:≈(y::MReal, z::Real)::Bool
function Base.:≈(y::MComplex, z::MComplex)::Bool
function Base.:≈(y::Complex, z::MComplex)::Bool
function Base.:≈(y::MComplex, z::Complex)::Bool</code></pre><p>Recall that <code>Int64</code>, <code>Rational{Int64}</code> and <code>Float64</code> are all instances of type <code>Real</code>.</p><h3 id="-6"><a class="docs-heading-anchor" href="#-6">&lt;</a><a class="docs-heading-anchor-permalink" href="#-6" title="Permalink"></a></h3><p>Binary operator <code>&lt;</code> tests to determine if the left argument is less than the right argument. This operator is overloaded to handle comparisons of</p><pre><code class="nohighlight hljs">function Base.:&lt;(y::MNumber, z::MNumber)::Bool
function Base.:&lt;(y::Real, z::MNumber)::Bool
function Base.:&lt;(y::MNumber, z::Real)::Bool</code></pre><h3 id="-7"><a class="docs-heading-anchor" href="#-7">≤</a><a class="docs-heading-anchor-permalink" href="#-7" title="Permalink"></a></h3><p>Binary operator <code>≤</code> tests to determine if the left argument is less than or equal to the right argument. This operator is overloaded to handle comparisons of</p><pre><code class="nohighlight hljs">function Base.:≤(y::MNumber, z::MNumber)::Bool
function Base.:≤(y::Real, z::MNumber)::Bool
function Base.:≤(y::MNumber, z::Real)::Bool</code></pre><h3 id="-8"><a class="docs-heading-anchor" href="#-8">≥</a><a class="docs-heading-anchor-permalink" href="#-8" title="Permalink"></a></h3><p>Binary operator <code>≥</code> tests to determine if the left argument is greater than or equal to the right argument. This operator is overloaded to handle comparisons of</p><pre><code class="nohighlight hljs">function Base.:≥(y::MNumber, z::MNumber)::Bool
function Base.:≥(y::Real, z::MNumber)::Bool
function Base.:≥(y::MNumber, z::Real)::Bool</code></pre><h3 id="-9"><a class="docs-heading-anchor" href="#-9">&gt;</a><a class="docs-heading-anchor-permalink" href="#-9" title="Permalink"></a></h3><p>Binary operator <code>&gt;</code> tests to determine if the left argument is greater than the right argument. This operator is overloaded to handle comparisons of</p><pre><code class="nohighlight hljs">function Base.:&gt;(y::MNumber, z::MNumber)::Bool
function Base.:&gt;(y::Real, z::MNumber)::Bool
function Base.:&gt;(y::MNumber, z::Real)::Bool</code></pre><h3 id="-10"><a class="docs-heading-anchor" href="#-10">+</a><a class="docs-heading-anchor-permalink" href="#-10" title="Permalink"></a></h3><p>Binary operator <code>+</code> adds the value held by the right argument to the value held by the left argument. This operator is overloaded to handle cases of</p><pre><code class="nohighlight hljs">function Base.:+(y::MInteger, z::MInteger)::Integer
function Base.:+(y::MInteger, z::Integer)::Integer
function Base.:+(y::Integer, z::MInteger)::Integer
function Base.:+(y::MRational, z::MRational)::Rational
function Base.:+(y::Union{Integer, Rational}, z::MRational)::Rational
function Base.:+(y::MRational, z::Union{Integer, Rational})::Rational
function Base.:+(y::MRational, z::MInteger)::Rational
function Base.:+(y::MInteger, z::MRational)::Rational
function Base.:+(y::MReal, z::MReal)::Real
function Base.:+(y::MReal, z::Union{MInteger,MRational})::Real
function Base.:+(y::Union{MInteger,MRational}, z::MReal)::Real
function Base.:+(y::MReal, z::Real)::Real
function Base.:+(y::Real, z::MReal)::Real
function Base.:+(y::MComplex, z::MComplex)::Complex
function Base.:+(y::MComplex, z::Complex)::Complex
function Base.:+(y::Complex, z::MComplex)::Complex
function Base.:+(y::MComplex, z::MNumber)::Complex
function Base.:+(y::MNumber, z::MComplex)::Complex
function Base.:+(y::MComplex, z::Real)::Complex
function Base.:+(y::Real, z::MComplex)::Complex</code></pre><h3 id="-11"><a class="docs-heading-anchor" href="#-11">-</a><a class="docs-heading-anchor-permalink" href="#-11" title="Permalink"></a></h3><p>Binary operator <code>-</code> subtracts the value held by the right argument from the value held by the left argument. This operator is overloaded to handle cases of</p><pre><code class="nohighlight hljs">function Base.:-(y::MInteger, z::MInteger)::Integer
function Base.:-(y::MInteger, z::Integer)::Integer
function Base.:-(y::Integer, z::MInteger)::Integer
function Base.:-(y::MRational, z::MRational)::Rational
function Base.:-(y::Union{Integer, Rational}, z::MRational)::Rational
function Base.:-(y::MRational, z::Union{Integer, Rational})::Rational
function Base.:-(y::MRational, z::MInteger)::Rational
function Base.:-(y::MInteger, z::MRational)::Rational
function Base.:-(y::MReal, z::MReal)::Real
function Base.:-(y::MReal, z::Real)::Real
function Base.:-(y::Real, z::MReal)::Real
function Base.:-(y::MReal, z::Union{MInteger,MRational})::Real
function Base.:-(y::Union{MInteger,MRational}, z::MReal)::Real
function Base.:-(y::MComplex, z::MComplex)::Complex
function Base.:-(y::MComplex, z::Complex)::Complex
function Base.:-(y::Complex, z::MComplex)::Complex
function Base.:-(y::MComplex, z::MNumber)::Complex
function Base.:-(y::MNumber, z::MComplex)::Complex
function Base.:-(y::MComplex, z::Real)::Complex
function Base.:-(y::Real, z::MComplex)::Complex</code></pre><h3 id="*"><a class="docs-heading-anchor" href="#*">*</a><a id="*-1"></a><a class="docs-heading-anchor-permalink" href="#*" title="Permalink"></a></h3><p>Binary operator <code>*</code> multiplies the value held by the left argument with the value held by the right argument. This operator is overloaded to handle cases of</p><pre><code class="nohighlight hljs">function Base.:*(y::MInteger, z::MInteger)::Integer
function Base.:*(y::MInteger, z::Integer)::Integer
function Base.:*(y::Integer, z::MInteger)::Integer
function Base.:*(y::MRational, z::MRational)::Rational
function Base.:*(y::Union{Integer, Rational}, z::MRational)::Rational
function Base.:*(y::MRational, z::Union{Integer, Rational})::Rational
function Base.:*(y::MRational, z::MInteger)::Rational
function Base.:*(y::MInteger, z::MRational)::Rational
function Base.:*(y::MReal, z::MReal)::Real
function Base.:*(y::MReal, z::Real)::Real
function Base.:*(y::Real, z::MReal)::Real
function Base.:*(y::MReal, z::Union{MInteger,MRational})::Real
function Base.:*(y::Union{MInteger,MRational}, z::MReal)::Real
function Base.:*(y::MComplex, z::MComplex)::Complex
function Base.:*(y::MComplex, z::Complex)::Complex
function Base.:*(y::Complex, z::MComplex)::Complex
function Base.:*(y::MComplex, z::MNumber)::Complex
function Base.:*(y::MNumber, z::MComplex)::Complex
function Base.:*(y::MComplex, z::Real)::Complex
function Base.:*(y::Real, z::MComplex)::Complex</code></pre><h3 id="-12"><a class="docs-heading-anchor" href="#-12">÷</a><a class="docs-heading-anchor-permalink" href="#-12" title="Permalink"></a></h3><p>Binary operator <code>÷</code> provides integer division where the left integer is divided by the right integer. This operator is overloaded to handle cases of</p><pre><code class="nohighlight hljs">function Base.:÷(y::MInteger, z::MInteger)::Integer
function Base.:÷(y::MInteger, z::Integer)::Integer
function Base.:÷(y::Integer, z::MInteger)::Integer</code></pre><h3 id="%"><a class="docs-heading-anchor" href="#%">%</a><a id="%-1"></a><a class="docs-heading-anchor-permalink" href="#%" title="Permalink"></a></h3><p>Binary operator <code>%</code> returns the remainder (or modulus) associated with an integer division. This operator is overloaded to handle the cases of</p><pre><code class="nohighlight hljs">function Base.:%(y::MInteger, z::MInteger)::Integer
function Base.:%(y::MInteger, z::Integer)::Integer
function Base.:%(y::Integer, z::MInteger)::Integer
</code></pre><h3 id="//"><a class="docs-heading-anchor" href="#//">//</a><a id="//-1"></a><a class="docs-heading-anchor-permalink" href="#//" title="Permalink"></a></h3><p>Binary operator <code>//</code> provides rational division where the left argument is divided by the right argument. This operator is overloaded to handle the cases of</p><pre><code class="nohighlight hljs">function Base.:(//)(y::MInteger, z::MInteger)::Rational
function Base.:(//)(y::MInteger, z::Union{Integer, Rational})::Rational
function Base.:(//)(y::Union{Integer, Rational}, z::MInteger)::Rational
function Base.:(//)(y::MRational, z::MRational)::Rational
function Base.:(//)(y::Rational, z::Union{MInteger, MRational})::Rational
function Base.:(//)(y::Union{MInteger, MRational}, z::Rational)::Rational
function Base.:(//)(y::MRational, z::Integer)::Rational
function Base.:(//)(y::Integer, z::MRational)::Rational</code></pre><h3 id="/"><a class="docs-heading-anchor" href="#/">/</a><a id="/-1"></a><a class="docs-heading-anchor-permalink" href="#/" title="Permalink"></a></h3><p>Binary operator <code>/</code> provides real and complex division where the left argument is divided by the right argument. This operator is overloaded to handle the cases of</p><pre><code class="nohighlight hljs">function Base.:/(y::MReal, z::MReal)::Real
function Base.:/(y::MReal, z::Real)::Real
function Base.:/(y::Real, z::MReal)::Real
function Base.:/(y::MReal, z::Union{MInteger,MRational})::Real
function Base.:/(y::Union{MInteger,MRational}, z::MReal)::Real
function Base.:/(y::MComplex, z::MComplex)::Complex
function Base.:/(y::MComplex, z::Complex)::Complex
function Base.:/(y::Complex, z::MComplex)::Complex
function Base.:/(y::MComplex, z::MNumber)::Complex
function Base.:/(y::MNumber, z::MComplex)::Complex
function Base.:/(y::MComplex, z::Real)::Complex
function Base.:/(y::Real, z::MComplex)::Complex</code></pre><h3 id="-13"><a class="docs-heading-anchor" href="#-13">^</a><a class="docs-heading-anchor-permalink" href="#-13" title="Permalink"></a></h3><p>Binary operator <code>^</code> raises the left argument to the power of the right argument. This operator is overloaded to handle the cases of</p><pre><code class="nohighlight hljs">function Base.:^(y::MInteger, z::MInteger)::Integer
function Base.:^(y::MInteger, z::Integer)::Integer
function Base.:^(y::Integer, z::MInteger)::Integer
function Base.:^(y::MReal, z::MReal)::Real
function Base.:^(y::MReal, z::Real)::Real
function Base.:^(y::Real, z::MReal)::Real
function Base.:^(y::MReal, z::Union{MInteger,MRational})::Real
function Base.:^(y::Union{MInteger,MRational}, z::MReal)::Real
function Base.:^(y::MComplex, z::MComplex)::Complex
function Base.:^(y::MComplex, z::Complex)::Complex
function Base.:^(y::Complex, z::MComplex)::Complex
function Base.:^(y::MComplex, z::MNumber)::Complex
function Base.:^(y::MNumber, z::MComplex)::Complex
function Base.:^(y::MComplex, z::Real)::Complex
function Base.:^(y::Real, z::MComplex)::Complex</code></pre><h2 id="Functions:-all-numeric-types."><a class="docs-heading-anchor" href="#Functions:-all-numeric-types.">Functions: all numeric types.</a><a id="Functions:-all-numeric-types.-1"></a><a class="docs-heading-anchor-permalink" href="#Functions:-all-numeric-types." title="Permalink"></a></h2><h3 id="abs"><a class="docs-heading-anchor" href="#abs">abs</a><a id="abs-1"></a><a class="docs-heading-anchor-permalink" href="#abs" title="Permalink"></a></h3><p>Function <code>abs()</code> extends function <code>Base.abs()</code>. It returns the absolute value of its argument.</p><pre><code class="nohighlight hljs">function Base.:(abs)(y::MInteger)::Integer
function Base.:(abs)(y::MRational)::Rational
function Base.:(abs)(y::MReal)::Real
function Base.:(abs)(y::MComplex)::Complex</code></pre><h2 id="Functions:-all-non-complex-numeric-types."><a class="docs-heading-anchor" href="#Functions:-all-non-complex-numeric-types.">Functions: all non-complex numeric types.</a><a id="Functions:-all-non-complex-numeric-types.-1"></a><a class="docs-heading-anchor-permalink" href="#Functions:-all-non-complex-numeric-types." title="Permalink"></a></h2><h3 id="sign"><a class="docs-heading-anchor" href="#sign">sign</a><a id="sign-1"></a><a class="docs-heading-anchor-permalink" href="#sign" title="Permalink"></a></h3><p>Function <code>sign()</code> extends function <code>Base.sign()</code>. It returns the sign of its argument.</p><pre><code class="nohighlight hljs">function Base.:(sign)(y::MNumber)::Real</code></pre><h2 id="Functions:-rational-numbers."><a class="docs-heading-anchor" href="#Functions:-rational-numbers.">Functions: rational numbers.</a><a id="Functions:-rational-numbers.-1"></a><a class="docs-heading-anchor-permalink" href="#Functions:-rational-numbers." title="Permalink"></a></h2><p>These functions extend their <code>Base</code> equivalents.</p><h3 id="Function-numerator()-returns-the-numerator-of-a-rational-number."><a class="docs-heading-anchor" href="#Function-numerator()-returns-the-numerator-of-a-rational-number.">Function <code>numerator()</code> returns the numerator of a rational number.</a><a id="Function-numerator()-returns-the-numerator-of-a-rational-number.-1"></a><a class="docs-heading-anchor-permalink" href="#Function-numerator()-returns-the-numerator-of-a-rational-number." title="Permalink"></a></h3><pre><code class="nohighlight hljs">function Base.:(numerator)(y::MRational)::Integer</code></pre><h3 id="Function-denominator()-returns-the-denominator-of-a-rational-number."><a class="docs-heading-anchor" href="#Function-denominator()-returns-the-denominator-of-a-rational-number.">Function <code>denominator()</code> returns the denominator of a rational number.</a><a id="Function-denominator()-returns-the-denominator-of-a-rational-number.-1"></a><a class="docs-heading-anchor-permalink" href="#Function-denominator()-returns-the-denominator-of-a-rational-number." title="Permalink"></a></h3><pre><code class="nohighlight hljs">function Base.:(denominator)(y::MRational)::Integer</code></pre><h2 id="Functions:-real-numbers."><a class="docs-heading-anchor" href="#Functions:-real-numbers.">Functions: real numbers.</a><a id="Functions:-real-numbers.-1"></a><a class="docs-heading-anchor-permalink" href="#Functions:-real-numbers." title="Permalink"></a></h2><p>These functions extend their <code>Base</code> equivalents.</p><h3 id="round"><a class="docs-heading-anchor" href="#round">round</a><a id="round-1"></a><a class="docs-heading-anchor-permalink" href="#round" title="Permalink"></a></h3><p>Function <code>round()</code> rounds the real value to its nearest integer value.</p><pre><code class="nohighlight hljs">function Base.:(round)(y::MReal)::Real</code></pre><h3 id="ceil"><a class="docs-heading-anchor" href="#ceil">ceil</a><a id="ceil-1"></a><a class="docs-heading-anchor-permalink" href="#ceil" title="Permalink"></a></h3><p>Function <code>ceil()</code> returns the ceiling of the supplied real, i.e., the nearest integer greater than or equal to its value.</p><pre><code class="nohighlight hljs">function Base.:(ceil)(y::MReal)::Real</code></pre><h3 id="floor"><a class="docs-heading-anchor" href="#floor">floor</a><a id="floor-1"></a><a class="docs-heading-anchor-permalink" href="#floor" title="Permalink"></a></h3><p>Function <code>floor()</code> returns the floor of the supplied real, i.e., the nearest integer less than or equal to its value.</p><pre><code class="nohighlight hljs">function Base.:(floor)(y::MReal)::Real</code></pre><h3 id="atan"><a class="docs-heading-anchor" href="#atan">atan</a><a id="atan-1"></a><a class="docs-heading-anchor-permalink" href="#atan" title="Permalink"></a></h3><p>Function <code>atan(y,x)</code> returns the inverse tangent of <code>y/x</code> where <code>y</code> is the rise and <code>x</code> is the run. In many languages this is denoted as <code>atan2</code>. The following additional cases are handled:</p><pre><code class="nohighlight hljs">function Base.:(atan)(y::MNumber, x::MNumber)::Real
function Base.:(atan)(y::MNumber, x::Real)::Real
function Base.:(atan)(y::Real, x::MNumber)::Real</code></pre><h2 id="Functions:-complex-numbers."><a class="docs-heading-anchor" href="#Functions:-complex-numbers.">Functions: complex numbers.</a><a id="Functions:-complex-numbers.-1"></a><a class="docs-heading-anchor-permalink" href="#Functions:-complex-numbers." title="Permalink"></a></h2><p>These functions extend their <code>Base</code> equivalents.</p><h3 id="abs2"><a class="docs-heading-anchor" href="#abs2">abs2</a><a id="abs2-1"></a><a class="docs-heading-anchor-permalink" href="#abs2" title="Permalink"></a></h3><p>Function <code>abs2()</code> returns the squared absolute value of its argument.</p><pre><code class="nohighlight hljs">function Base.:(abs2)(y::MComplex)::Real</code></pre><h3 id="real"><a class="docs-heading-anchor" href="#real">real</a><a id="real-1"></a><a class="docs-heading-anchor-permalink" href="#real" title="Permalink"></a></h3><p>Function <code>real()</code> returns the real part of its complex argument.</p><pre><code class="nohighlight hljs">function Base.:(real)(y::MComplex)::Real</code></pre><h3 id="imag"><a class="docs-heading-anchor" href="#imag">imag</a><a id="imag-1"></a><a class="docs-heading-anchor-permalink" href="#imag" title="Permalink"></a></h3><p>Function <code>imag()</code> returns the imaginary part of its complex argument.</p><pre><code class="nohighlight hljs">function Base.:(imag)(y::MComplex)::Real</code></pre><h3 id="conj"><a class="docs-heading-anchor" href="#conj">conj</a><a id="conj-1"></a><a class="docs-heading-anchor-permalink" href="#conj" title="Permalink"></a></h3><p>Function <code>conj()</code> returns the complex conjugate of its complex argument.</p><pre><code class="nohighlight hljs">function Base.:(conj)(y::MComplex)::Complex</code></pre><h3 id="angle"><a class="docs-heading-anchor" href="#angle">angle</a><a id="angle-1"></a><a class="docs-heading-anchor-permalink" href="#angle" title="Permalink"></a></h3><p>Function <code>angle()</code> returns the angle in radians of the complex argument.</p><pre><code class="nohighlight hljs">function Base.:(angle)(y::MComplex)::Real</code></pre><h2 id="Functions:-math"><a class="docs-heading-anchor" href="#Functions:-math">Functions: math</a><a id="Functions:-math-1"></a><a class="docs-heading-anchor-permalink" href="#Functions:-math" title="Permalink"></a></h2><p>These functions extend their <code>Base</code> equivalents.</p><p>Function <code>sin()</code> returns the sine of the argument, which is in radians.</p><pre><code class="nohighlight hljs">function Base.:(sin)(y::MNumber)::Real
function Base.:(sin)(y::MComplex)::Complex</code></pre><p>Function <code>cos()</code> returns the cosine of the argument, which is in radians.</p><pre><code class="nohighlight hljs">function Base.:(cos)(y::MNumber)::Real
function Base.:(cos)(y::MComplex)::Complex</code></pre><p>Function <code>tan()</code> returns the tangent of the argument, which is in radians.</p><pre><code class="nohighlight hljs">function Base.:(tan)(y::MNumber)::Real
function Base.:(tan)(y::MComplex)::Complex</code></pre><p>Function <code>sinh()</code> returns the hyperbolic sine of the argument.</p><pre><code class="nohighlight hljs">function Base.:(sinh)(y::MNumber)::Real
function Base.:(sinh)(y::MComplex)::Complex</code></pre><p>Function <code>cosh()</code> returns the hyperbolic cosine of the argument.</p><pre><code class="nohighlight hljs">function Base.:(cosh)(y::MNumber)::Real
function Base.:(cosh)(y::MComplex)::Complex</code></pre><p>Function <code>tanh()</code> returns the hyperbolic tangent of the argument.</p><pre><code class="nohighlight hljs">function Base.:(tanh)(y::MNumber)::Real
function Base.:(tanh)(y::MComplex)::Complex</code></pre><p>Function <code>asin()</code> returns the inverse of the sine of the argument.</p><pre><code class="nohighlight hljs">function Base.:(asin)(y::MNumber)::Real
function Base.:(asin)(y::MComplex)::Complex</code></pre><p>Function <code>acos()</code> returns the inverse of the cosine of the argument.</p><pre><code class="nohighlight hljs">function Base.:(acos)(y::MNumber)::Real
function Base.:(acos)(y::MComplex)::Complex</code></pre><p>Function <code>atan()</code> returns the inverse of the tangent of the argument.</p><pre><code class="nohighlight hljs">function Base.:(atan)(y::MNumber)::Real
function Base.:(atan)(y::MComplex)::Complex</code></pre><p>Function <code>asinh()</code> returns the inverse of the hyperbolic sine of the argument.</p><pre><code class="nohighlight hljs">function Base.:(asinh)(y::MNumber)::Real
function Base.:(asinh)(y::MComplex)::Complex</code></pre><p>Function <code>acosh()</code> returns the inverse of the hyperbolic cosine of the argument.</p><pre><code class="nohighlight hljs">function Base.:(acosh)(y::MNumber)::Real
function Base.:(acosh)(y::MComplex)::Complex</code></pre><p>Function <code>atanh()</code> returns the inverse of the hyperbolic tangent of the argument.</p><pre><code class="nohighlight hljs">function Base.:(atanh)(y::MNumber)::Real
function Base.:(atanh)(y::MComplex)::Complex</code></pre><p>Function <code>log()</code> returns the natural logarithm of the argument.</p><pre><code class="nohighlight hljs">function Base.:(log)(y::MNumber)::Real
function Base.:(log)(y::MComplex)::Complex</code></pre><p>Function <code>log2()</code> returns the logarithm of the argument in base 2.</p><pre><code class="nohighlight hljs">function Base.:(log2)(y::MNumber)::Real
function Base.:(log2)(y::MComplex)::Complex</code></pre><p>Function <code>log10()</code> returns the logarithm of the argument in base 10.</p><pre><code class="nohighlight hljs">function Base.:(log10)(y::MNumber)::Real
function Base.:(log10)(y::MComplex)::Complex</code></pre><p>Function <code>exp()</code> returns the exponential of the argument, which is the inverse function to <code>log()</code>.</p><pre><code class="nohighlight hljs">function Base.:(exp)(y::MNumber)::Real
function Base.:(exp)(y::MComplex)::Complex</code></pre><p>Function <code>exp2()</code> returns the exponential of the argument in base 2, which is the inverse function to <code>log2()</code>.</p><pre><code class="nohighlight hljs">function Base.:(exp2)(y::MNumber)::Real
function Base.:(exp2)(y::MComplex)::Complex</code></pre><p>Function <code>exp10()</code> returns the exponential of the argument in base 10, which is the inverse function to <code>log10()</code>.</p><pre><code class="nohighlight hljs">function Base.:(exp10)(y::MNumber)::Real
function Base.:(exp10)(y::MComplex)::Complex</code></pre></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.21 on <span class="colophon-date" title="Thursday 28 July 2022 08:47">Thursday 28 July 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
